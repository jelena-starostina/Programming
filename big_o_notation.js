//Big O Notation
//Классическое понятие - 
//Асимптотическая сложность алгоритма - 
//О(n) , где n - размер входных данных

//Иными словами - способ описать, как будет расти время
//выполнение алгоритма в зависимости от роста входных данных

//------------------------------------------------------
//константная сложность О(1) (Constant Time)
//время выполнения не зависит от размера входных данных
function getFirstElement(arr) {
    return arr[0];
}

console.log(getFirstElement([1, 2, 3, 4, 5])); // 1
const array2 = new Array(1000000).fill("test");
console.log(getFirstElement(array2)); // "test"

//-------------------------------------------------------

//линейная сложность О(n) (Linear Time)
//время выполнения растёт линейно с ростом входных данных
//если 'n' удваивается, время выполнения тоже удваивается
console.log("---O(n) Линейная сложность---");

//Пример - найти сумму всех чисел в массиве
//чтобы найти сумму, нужно пройтись по КАЖДОМУ элементу массива
function sumArray(arr) {
    let sum = 0;
    for (let i = 0; i < arr.length; i++) { //arr.length  это наше 'n'
        sum += arr[i]; //цикл выполняется n раз
}
return sum;
}
console.log(sumArray([1, 2, 3, 4, 5])); // 15
const array1 = new Array(1000000).fill(1);
console.log(sumArray(array1)); // 1000000

//O(n^2) - Квадратичная сложность (Quadratic Time)
//Время выполнения растёт квадратично с ростом входных данных
//если 'n' удваивается, время выполнения увеличивается в 4 раза
console.log("---O(n^2) Квадратичная сложность---");

//Пример - найти все дубликаты в массиве
function hasDuplicates(arr) {
    const n = arr.length;
    for (let i = 0; i < n; i++) {                             //Внешний цикл выполняется n раз
        for (let j = i + 1; j < n; j++) {  //внутренний цикл тоже выполняется n раз
            if (i !== j && arr[i] === arr[j]) {
                return true; // Найден дубликат
            }
            
        }
    }
    return false; // Дубликаты не найдены
}
console.log(hasDuplicates([1, 2, 3, 4, 5])); // false
console.log(hasDuplicates([1, 2, 3, 4, 5, 3])); // true
//-----------------------------------------------------------
//Логарифмическая сложность O(log n) (Logarithmic Time)
//Время выполнения растёт логарифмически с ростом входных данных
//если 'n' удваивается, время выполнения увеличивается на 1
console.log("---O(log n) Логарифмическая сложность---");

/** 
 * Пример - бинарный поиск в отсортированном массиве
 * 
 * Бинарный поиск работает по тринципу "разделяй и властвуй"
 * Он делит массив пополам и определяет, в какой половине
 * может находиться искомый элемент, затем повторяет процесс для этой половины.
 * /